import concurrent
#from map.PysharkPackage.pysharkProj import runPyshark
from map.PysharkPackage.pysharkProj import runPyshark

from django.shortcuts import render, redirect
import folium
import geocoder
import json
from django.http import HttpResponseRedirect, HttpResponse
from .forms import FileForm
from .models import File
from .models import RaportFile
# from map.PysharkPackage import pysharkProj
# from map.PysharkPackage import parseRaport
# from map.PysharkPackage import RCS_Exp
# Create your views here.
from django.db import models




class View:
    full_files_path = []
    full_json_files_path = []
    Wrong_Extension = False
    file_list = []
    nullcap = [] # will hold either True, or False. Example: We upload 3 files. If file 2 has no useful information and the rest did
    # nullcap will look like this = [True, False, True]
    # OR if the file has unsupported type ! It achieves the same functionality

    # This method will handle the home page along with file(s) upload and processing ( will call background script to process .cap file )
    @classmethod
    def uploadFile(cls, request):
        files = File.objects.all()
        for file in files:
            file.delete()
        message = 'This is an application for processing wireshark ( or equivalent ) capture files (.cap, .pcapng, etc.).'
        context = {}

        # Handle file upload
        if request.method == 'POST':
            form = FileForm(request.POST, request.FILES)
            if form.is_valid():
                cls.file_list = request.FILES.getlist('file')
                nrOfProcesses = len(cls.file_list)
                if nrOfProcesses <= 5:
                    cls.full_files_path.clear()
                    cls.full_json_files_path.clear()
                    cls.nullcap.clear()
                    fileObjList = []
                    for fname in cls.file_list:
                        newfile = File(file=fname)
                        newfile.save()
                        fileObjList.append(newfile)

                    results = []
                    results_list = []
                    nextFunctionInterations = nrOfProcesses
                    with concurrent.futures.ThreadPoolExecutor(max_workers=nrOfProcesses) as e:
                        results = e.map(start_Parse, fileObjList)

                        while nextFunctionInterations > 0:
                            results_list.append(next(results))
                            nextFunctionInterations = nextFunctionInterations - 1

                    cls.Wrong_Extension = results_list[0][3]
                    for idx,element in enumerate(results_list):
                        cls.nullcap.append(not element[0])
                        cls.full_files_path.append(element[1])
                        cls.full_json_files_path.append(element[2])
                        RaportFile().file.name = element[1]
                        if cls.nullcap[idx] is False:
                            cls.Wrong_Extension = element[3]
                            cls.nullcap[idx] = cls.Wrong_Extension

                    return redirect('list-of-captures')

                elif len(cls.file_list) > 5:
                    message = 'Please select a maximum of 5 capture files!'
            else:
                message = 'The form is not valid.'
        else:
            form = FileForm()  # empty form

        context.update({'form': form, 'message': message})
        return render(request, 'index.html', context)


    # If the user tries to upload more than 5 capture files, throw this
    @classmethod
    def ExceededLimit(cls,request):
        message = "Can't parse more than 5 capture files at a time. Try again"
        return render(request, 'FailedParse.html', {'message':message})


    # This view will create the list of captures that are good ( holds useful information or are supported type ).
    @classmethod
    def ListOfCaptures(cls, request):
        context = {}
        dict_list = []
        rmv = cls.badCapfiltering()

        if rmv:
            context.update({'rmv': rmv})
        i = 0
        if len(cls.file_list) == 0:
            processingfailed = True
            context.update({'processingfailed': processingfailed})
        while i < len(cls.file_list):
            file_name = cls.file_list[i]

            raport = cls.full_files_path[i]
            raportJson = cls.full_json_files_path[i]
            dict = {
                'file_name':str(file_name),
                'raport':raport,
                'raportJson': raportJson
            }
            dict_list.append(dict)
            i += 1
        context.update({'listDict':dict_list})
        return render(request, 'parsedList.html', context)


    # Filter the non-useful and non-supported uploaded files USING cls.nullcap list ( the most important piece )
    @classmethod
    def badCapfiltering(cls):
        rmv = False
        new_fl_list = []
        new_fullpath = []
        new_fulljsonpath = []
        for idx, boolean in enumerate(cls.nullcap):
            if not boolean:
                new_fl_list.append(cls.file_list[idx])
                new_fullpath.append(cls.full_files_path[idx])
                new_fulljsonpath.append(cls.full_json_files_path[idx])
            else:
                rmv = True

        cls.file_list = new_fl_list.copy()
        cls.full_files_path = new_fullpath.copy()
        cls.full_json_files_path = new_fulljsonpath.copy()
        n = len(cls.file_list)
        cls.nullcap = [False]*n
        return rmv



    @classmethod
    def show_Raport(cls, request):
        lines = []
        f_path = request.POST.get('selection')
        if f_path != None:
            try:
                with open(f_path, "r") as infile:
                    while True:
                        line = infile.readline()
                        if not line:
                            break
                        else:
                            lines.append(line)
            except:
                return redirect('failed-parse')
        context = {'lines': lines}
        return render(request, 'text-raport.html', context)



    # Creates the leaflet map ( if needed ) and all the text from the raport.
    @classmethod
    def map_And_Raport(cls, request):
        # Parse json file
        jsonPath = request.POST.get('jsonfile')
        jsonFile = open(jsonPath)
        output = json.load(jsonFile)

        m = folium.Map()
        context = {}
        hasLocation = False
        for packet in output:
            coord1 = float(packet['Coord1'])
            coord2 = float(packet['Coord2'])
            if coord1 and coord2:
                hasLocation = True
            pp = "Source_IP=" + packet['Source_IP'] + " Destination_IP=" + packet['Destination_IP'] + " Time: " + \
                 packet['Time'] + " Device: " + packet['Device_Info']
            ttp = packet['Coord1'] + ", " + packet['Coord2']
            folium.Marker([coord1, coord2], tooltip=ttp, popup=pp).add_to(m)
            # Create Map Object
            # m = folium.Map(location=[19, -12], zoom_start=2)
        jsonFile.close()
        m = m._repr_html_()  # html representation of Map object


        txt_Path = request.POST.get('textfile')
        lines = []
        if txt_Path != None:
            try:
                with open(txt_Path, "r") as infile:
                    while True:
                        line = infile.readline()
                        if not line:
                            break
                        else:
                            lines.append(line)
            except:
                return redirect('failed-parse')
        context = {'lines': lines, 'm':m, 'hasLocation':hasLocation}
        return render(request, 'map-and-raport.html', context)




    @classmethod
    def succes_parse(cls,request):
        message = 'The capture file has been parsed succesfully!'
        return render(request, 'succesParsed.html', {})



    @classmethod
    def failed_parse(cls,request):
        return render(request, 'FailedParse.html', {})



# Calls the background script to process capture file
def start_Parse(uploadedFlPath):
    filePath = uploadedFlPath.file.path
    found_something = False
    Full_File_Name = ""
    Full_JsonFile_Name = ""
    Wrong_Extension = False
    try:
        found_something, Full_File_Name, Full_JsonFile_Name, Wrong_Extension = runPyshark(filePath)
    except Exception as e:
        print('Exception in start_Parse')
        print(e)
    return found_something, Full_File_Name, Full_JsonFile_Name, Wrong_Extension









