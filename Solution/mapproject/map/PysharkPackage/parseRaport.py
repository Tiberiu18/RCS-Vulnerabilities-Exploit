import collections
import json
import numpy as np
from map.PysharkPackage.Constants import Constants
from map.PysharkPackage.Configurate import Pattern
import os
import ipaddress


class ParseRaport:
    raport_Num = 0
    def __init__(self, jsonP):
        self.jsonPath = jsonP
        self.raports = []
        self.coordsRecord = []


    # This function will append to a text file the input string.
    #[in] - input string to be appended to a text file (stringVal)
    def writeToText(self, stringVal):
        Full_File_Name= Constants.Raports_Dir_Path + Constants.Text_Files_Name +  "_" + str(self.raport_Num) + ".txt"
        with open(Full_File_Name, "a") as ofile:
            ofile.write(stringVal)
            ofile.write("\n")





    # This functions finds the latest file named in a certain way ( that is the BasefileName).
    # Example: If a directory has 3 files: text_1.txt, text_2.txt, text_3.txt
    # This function will set self.raport_Num to 3 !
    # [in] -> A base name to search for in directory. For the above example, that would be "text"
    # [out] -> will set self.raport_Num ( See above ).
    def findRaportNum(self, dir, BasefileName):
        fileNumList = []
        try:
            os.mkdir(Constants.Raports_Dir_Path)
        except:
            pass
        for file in os.listdir(dir): # raport_x.txt
            if file.endswith(".txt"):
                if "_" in file:
                    size = len(file)
                    file = file[:size-4]
                    splittedName = file.split("_")
                    auxStr = ""
                    for i in range(len(splittedName) - 1):
                        auxStr += splittedName[i]
                    if splittedName[len(splittedName) - 1].isnumeric() and auxStr == BasefileName:
                        fileNumList.append(int(splittedName[len(splittedName) - 1]))
        if len(fileNumList) > 0:
            self.raport_Num = max(fileNumList)






    # This function processes the intermediary json file obtained after converting a .cap file ( Capture file ) .
    # [in] - patterns -> list of Pattern objects. Pattern object has the same format as the json file named "patterns",
    # return - if any packets had useful information => found_something = True, else False,
    # return - the full path to the .text raport ( Full_File_Name),
    # return - the full path to the .json raport ( Full_JsonFile_Name ).
    def parse_JsonFull(self, patterns):
        jsonFile = open(self.jsonPath)

        output = json.load(jsonFile)

        raport_txt = ""

        self.findRaportNum(Constants.Raports_Dir_Path, Constants.Text_Files_Name)

        self.raport_Num += 1
        found_something = False
        PossiblePacketTypes = [x.upper() for x in Pattern.PossibleTypes]
        k = 1
        prevMsg = {}
        locationTmp = 0
        tp = str
        delay = 999
        for packet in output:
            message = self.CheckPattern(packet, patterns)
            currTsmp = float(packet['Timestamp'])
            if len(message) > 0:
                for tp in PossiblePacketTypes:
                    if tp in message.upper():
                        if tp in prevMsg:
                            tpTsmp = prevMsg[tp]
                            delay = abs(currTsmp - tpTsmp)
                            if delay > Constants.timestamp_minDelay:
                                del prevMsg[tp]
                                self.writeToText("#" + str(k) + " -> " + "Time: " + packet['Time'] + " | " + message)
                                k = k + 1
                        else:
                            self.writeToText("#" + str(k) + " -> " + "Time: " + packet['Time'] + " | " + message)
                            k = k + 1
                        prevMsg[tp] = currTsmp
                        break

                found_something = True

            if packet['Coord1'] != "None":
                currTsmp = float(packet['Timestamp'])
                delay = abs(currTsmp - locationTmp)
                locationTmp = currTsmp
                if delay > Constants.timestamp_minDelay:
                    c1 = float(packet['Coord1'])
                    c2 = float(packet['Coord2'])
                    self.coordsRecord.append([c1, c2])
                    if packet['Destination_IP'].split(".")[0] != "192":
                        raport_txt = ''' #{0} -> At time {1} a packet containing coordonates {2} {3} from the device {4} going to port {5} and IP {6} has been intercepted\
                          '''.format(k, packet['Time'], packet['Coord1'], packet['Coord2'],
                                     packet['Device_Info'], packet['Destination_Port'], packet['Destination_IP'])
                        self.writeToText(raport_txt)

                        found_something = True


                    # If we are the Source, we have a Private Ip address ( 192.x.x.x) and we are sending to Public IP address ( not 192.x.x.x) to port X(80)
                    # If we receive from that Public IP => Source_IP not 192.x.x.x and coming from port X(80)
                    if packet['Source_IP'].split(".")[0] != "192":
                        raport_txt = ''' #{0} -> At time {1} and timestamp {2} a packet containing coordonates {3} {4} coming from port {5} and IP {6} has been intercepted\
                                              '''.format(k,packet['Time'], packet['Timestamp'], packet['Coord1'],
                                                         packet['Coord2'],
                                                         packet['Source_Port'], packet['Source_IP'])
                        self.writeToText(raport_txt)
                        found_something = True
                    k = k + 1

                    dict = {
                        "Packet_Num": packet['Packet_Num'],
                        "Source_IP": packet['Source_IP'],
                        "Destination_IP": packet['Destination_IP'],
                        "Source_Port": packet['Source_Port'],
                        "Destination_Port": packet['Destination_Port'],
                        "Length": packet['Length'],
                        "Time": packet['Time'],
                        "Timestamp": packet['Timestamp'],
                        "Coord1": packet['Coord1'],
                        "Coord2": packet['Coord2'],
                        "Device_Info": packet['Device_Info']
                    }
                    self.raports.append(dict)


        Full_JsonFile_Name = self.RaportToJson()

        self.coordsRecord = list(set(map(tuple,self.coordsRecord)))

        jsonFile.close()

        Full_File_Name = Constants.Raports_Dir_Path + Constants.Text_Files_Name + "_" + str(self.raport_Num) + ".txt"

        return found_something, Full_File_Name, Full_JsonFile_Name



    # This function will create a .json file containing the summary of a capture file.
    # return - full path to that .json file ( see above ).
    def RaportToJson(self):
        Full_File_Name = Constants.Raports_Dir_Path + Constants.Json_Files_Name + "_" + str(self.raport_Num) + ".json"
        with open(Full_File_Name, "w") as outfile:
            json.dump(self.raports, outfile, default=str, indent=2)
        return Full_File_Name


    def getCoords(self):
        return self.coordsRecord



    # [in] - packet -> Capture packet ( network packet )
    # [in] - patterns -> list of Pattern objects. Pattern object has the same format as the json file named "patterns"
    # return - message -> if package has found a relevant pattern or not
    def CheckPattern(self, packet, patterns):
        message = ""
        IPDest = packet['Destination_IP']
        Port = int(packet['Destination_Port'])
        Length = int(packet['Length'])
        try:
            ptnObj = Pattern.IPxTypeMap[IPDest]
            # If not working like this, try this approach, maybe the pattern has an IP + CIDR
            message += "Intercepted " + ptnObj.Type + ", " + "IP: " + str(IPDest)
        except Exception as e:
            for ptn in patterns:
                for net in ptn.getIPsDest():
                    if ipaddress.ip_address(IPDest) in ipaddress.ip_network(net):
                        message += "Intercepted " + ptn.Type + ", " + "IP: " + str(IPDest)
                        break
        return message