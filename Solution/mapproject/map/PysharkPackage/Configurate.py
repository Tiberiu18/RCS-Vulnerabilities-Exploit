import json
from enum import Enum
from netaddr import IPNetwork
import socket
import struct

class ConfigEnum(Enum):
    RCSON = 1
    TEXTMESSAGE = 2
    MEDIAMESSAGE = 3
    LOCATIONMESSAGE = 4


class Pattern:
    IPxTypeMap = dict()
    PossibleTypes = ["RCS Initialization","Text Message", "Media message", "Location message"]
    def __init__(self, Type, IPDest, Port, Length):
        self.Type = Type
        self.transform()
        self.IPDest = IPDest
        self.Port = Port
        self.Length = Length
        for ip in IPDest:
            Pattern.IPxTypeMap[ip] = self

    def ParameterizedtoString(self, IP):
        message = "Type:" + self.Type + ", IPDest=" + str(IP) + '' + ", Port=" + str(
            self.Port) + ", Length=" + str(self.Length)
        return message

    def transform(self):
        if self.Type.strip().upper() == ConfigEnum.RCSON.name:
            self.Type = "RCS Initialization"
        elif self.Type.strip().upper() == ConfigEnum.TEXTMESSAGE.name:
            self.Type = "Text Message"
        elif self.Type.strip().upper() == ConfigEnum.MEDIAMESSAGE.name:
            self.Type = "Media message"
        elif self.Type.strip().upper() == ConfigEnum.LOCATIONMESSAGE.name:
            self.Type = "Location message"

    def getIPsDest(self):
        return self.IPDest

    @classmethod
    def getPatternsMap(cls):
        return cls.IPxTypeMap




    # Adds to the self object a list of all IP's in range
    def TransformMask(self):
        for ip in self.IPDest:
            str_split = ip.split('/')
            if len(str_split) == 2: # If string has been split
                ip_addr = str_split[0]
                netmask = cidr_to_netmask(str_split[1])
                network = IPNetwork('/'.join([ip_addr, netmask]))
                generator = network.iter_hosts()
                for ip_addr in list(generator):
                    self.IPDest.append(format(ip_addr))


# Transforms CIDR to Netmask. For example: /16 => 255.255.0.0
def cidr_to_netmask(cidr):
    net_bits = cidr
    host_bits = 32 - int(net_bits)
    netmask = socket.inet_ntoa(struct.pack('!I', (1 << 32) - (1 << host_bits)))
    return netmask


# This functions reads the patterns .json
# return - list of patterns constructed by reading the .json file
def readjson(path):
    jsonf = open(path)
    data = json.load(jsonf)
    list_ptn = []
    for ptn in data:
        Type = ptn['Type']
        IPDest = []
        for ip in ptn['IPDest']:
            IPDest.append(ip)
        Port = int(ptn['Port'])
        Length = int(ptn['Length'])
        pattern = Pattern(Type, IPDest, Port, Length)
        list_ptn.append(pattern)
    return list_ptn


